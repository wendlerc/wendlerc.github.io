<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rope</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 2em;
    }
    pre {
      background: #f6f8fa;
      padding: 1em;
      border-radius: 5px;
      overflow-x: auto;
      margin: 1.5em 0;
    }
    code {
      font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      background: #f6f8fa;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-size: 85%;
    }
    pre code {
      background: none;
      padding: 0;
      font-size: 92%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      font-weight: 600;
      line-height: 1.25;
    }
    h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    p { margin: 1em 0; }
    a {
      color: #0366d6;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    img {
      max-width: 100%;
      box-sizing: content-box;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    table, th, td {
      border: 1px solid #dfe2e5;
    }
    th, td {
      padding: 6px 13px;
      text-align: left;
    }
    tr:nth-child(even) {
      background-color: #f6f8fa;
    }
    blockquote {
      margin: 0;
      padding: 0 1em;
      color: #6a737d;
      border-left: 0.25em solid #dfe2e5;
    }
    ul, ol {
      padding-left: 2em;
    }
    /* Syntax highlighting styles */
    .highlight .c, .highlight .cm, .highlight .c1, .highlight .cs { color: #6a737d; } /* Comment */
    .highlight .k, .highlight .kc, .highlight .kd, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kt { color: #d73a49; } /* Keyword */
    .highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .s1 { color: #032f62; } /* String */
    .highlight .na, .highlight .bp { color: #005cc5; } /* Name.Attribute, Name.Builtin.Pseudo */
    .highlight .nb, .highlight .nc, .highlight .nf { color: #6f42c1; } /* Name.Builtin, Name.Class, Name.Function */
    .highlight .no, .highlight .nd, .highlight .ni, .highlight .ne, .highlight .nv { color: #e36209; } /* Name.Constant, Name.Decorator, etc */
    .highlight .o, .highlight .ow { color: #d73a49; } /* Operator, Operator.Word */
    .highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .mo { color: #005cc5; } /* Literal.Number */
  </style>
  <!-- MathJax for rendering math equations -->
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <h1 id="notes-on-rotary-positional-embeddings-rope">Notes on rotary positional embeddings (RoPE)</h1>
<p><strong>Chris Wendler,</strong>
<strong>08/19/25,</strong>
<strong>last updated: 08/29/25</strong></p>

<p>If you find mistakes or typos please reach out to me.</p>

<h2 id="summary">Summary</h2>

<p>Let \(D\) be the dimension of the residual stream and \(d &lt; D\) the dimension of an attention head.</p>

<p>Let 
\(R^{d}_{\Theta, m} = 
\begin{pmatrix}
\cos{m\theta_1} &amp; -\sin{m\theta_1} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
\sin{m\theta_1} &amp; \cos{m\theta_1} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \cos{m\theta_2} &amp; -\sin{m\theta_2} &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \sin{m\theta_2} &amp; \cos{m\theta_2} &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos{m\theta_{d/2}} &amp; -\sin{m\theta_{d/2}} \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \sin{m\theta_{d/2}} &amp; \cos{m\theta_{d/2}} \\
\end{pmatrix}.\)</p>

<p>Then, we update keys using \(k_n = R^{d}_{\Theta, n} W_k x_n\) 
and queries using \(q_m = R^{d}_{\Theta, m} W_q x_m\).</p>

<p>Their dot product simplifies to (due to composition of rotation matrices)
\(q_m^T k_n = x_m^T W_q^T R^{d}_{\Theta, n - m} W_k x_n.\)</p>

<p>For more details, check out the <a href="https://arxiv.org/abs/2104.09864">RoPE paper</a>.</p>

<h2 id="position-only-attention-heads">Position-only attention heads</h2>

<p>Given positional information only enters via RoPE, how can an attention head be achieved that solely relies on positional information?</p>

<h3 id="previous-token-heads">Previous token heads</h3>

<p>Let’s try to implement a simple previous token head using RoPE. This head should attend mostly to the previous token. E.g., \(q_{n+1}\) should mostly match with \(k_n\) and so on.</p>

<p>Their dot product simplifies to 
\(q_{n+1}^T k_n = x_{n+1}^T W_q^T R^{d}_{\Theta, -1} W_k x_n.\)</p>

<p>Without assumptions I don’t see a straightforward way to achieve this previous token head. However, after discussing with my friend Jakob Heiss, we had the idea that we could assume that the model either has a bias term (one of the components of \(x_i \in \mathbb{R}^D\) is a constant value) either because that bias term is hardcoded or because the previous layers have learned to create one.</p>

<p>Thus, w.l.o.g. let’s assume that for each \(i\) we have \(x_{i1} = 1\) (using 1-based indexing). Now, this can be used to create keys and queries that solely depend on the positional information.</p>

<p>Then, we could set \(W_k\) such that, for all \(i\), \(W_k x_{i} = (1, 0, 1, 0, \cdots, 1, 0)^T\). That is, 
\(W_{kij} := \begin{cases}
1 &amp;&amp; \text{if } j = 1 \text{ and } i \text{ is odd,}\\
0 &amp;&amp; \text{else.}
\end{cases}\)</p>

<p>\(W_q\) such that \(W_q x_{n+1}\) matches \(R^{d}_{\Theta, -1} (1, 0, 1, 0, \cdots, 1, 0)^T = (\cos{\theta_1}, -\sin{\theta_1}, \cdots, \cos{\theta_{d/2}}, -\sin{\theta_{d/2}})\) to maximize the dot product with \(k_{n}\). Additionally, we can add a temperature parameter to control how sharp we want the attention head to be. Both can be achieved by setting \(W_q := \alpha R^{d}_{\Theta, -1} W_k,\) in which \(\alpha &gt; 0\) is a temperature parameter.</p>

<p>As a result, for \(q_{n+1}\) we have that \(q_{n+1}^T k_n = (d/2)\alpha\) and \(q_{n+1}^T k_m = \alpha \sum_{\ell = 1}^{d/2} \cos{((m - n)\theta_{\ell})} &lt; (d/2)\alpha\), for \(m &lt; n\). Thus, for large \(\alpha\) the softmax operation in the attention layer should mostly select the key at position \(n\). Empirically (for sequence length 20, \(D = 768\), \(d = 64\)) we have:</p>

<p><strong>Experiment 1 (previous token head by hand).</strong></p>

<p>\(\alpha = 1\):</p>

<p><img src="./rope/prev_1.png" alt="alpha=1" /></p>

<p>\(\alpha = 10\):</p>

<p><img src="./rope/prev_10.png" alt="alpha=10" /></p>

<p>\(\alpha = 100\):</p>

<p><img src="./rope/prev_100.png" alt="alpha=100" /></p>

<p><strong>Experiment 2 (finding purely positional heads).</strong> If transformers converge to an implementation similar to the one presented here, which leverages this single constant dimension (and is equivalent to having a one-dimensional subspace spanned by $u$ with the property \(u^T x_i = c\) with \(c \in \mathbb{R}\), for all \(i\)), it should be possible to find purely positional heads by searching for heads with \(\mbox{rank}(W_Q) = \mbox{rank}(W_K) = 1\). There may be other rank 1 heads as well, but the set of rank 1 heads should also contain all the purely positional ones that are implemented in this way.</p>

<h2 id="semantic-heads">Semantic heads</h2>

<p>Purely semantic heads, i.e., heads ignoring the positional information at first glance look challenging to implement with RoPE. This is because the pair-of-coordinate-wise rotations are applied to keys and queries right before computing the dot products. So strictly speaking it is not possible to fully get rid of the positional information. However, one can approximately get rid of it and minimize its effect of the positional information by only using the “last few” dimensions of the keys and queries for the semantic matching. The rationale behind this is to leverage the coordinates that are rotated the least (the last 2-components of the key and query vector are only rotated by an \(10^{-4}\) rad).</p>

<p>Let’s do a small example, in which we first don’t address the positional encodings at all and then one in which we leverage only the last few coordinates.</p>

<h4 id="rope-introduces-a-recency-bias">RoPE introduces a recency bias</h4>

<p>Let \(x_1 = x_2 = x_3 = \cdots = x_n = x\) and let \(W_Q = W_K = (\mathbf{I}_{d} \mid \mathbf{0})\), in which \(\mathbf{I}_d\) is the \(d\)-dimensional identity matrix and \(\mathbf{0} \in \mathbb{R}^{d \times (D - d)}\) a matrix of zeros. Let \(x'\) denote the first \(d\) components of \(x\). The unnormalized attention scores become proportional to the cosine of the angle between \(x'\) and \(R^{d}_{\Theta, n-m} x'\): 
\(q_{m}^T k_n = x'^T R^{d}_{\Theta, n-m} x' = \|x'\|_2^2\cos(\angle(x', R^{d}_{\Theta, n-m} x')),\) which is maximized for \(n = m\) (i.e. for \(R^d_{\Theta, 0} = I\)).</p>

<p>\(x'^T R^{d}_{\Theta, n-m} x' = \|x'\|_2^2\cos(\angle(x', R^{d}_{\Theta, n-m} x')) = \sum_{i = 1}^{d/2} \underbrace{\cos((n-m)\theta_i)}_{\text{positional}}\underbrace{(x_{2i - 1}^2 + x_{2i}^2)}_{\text{semantic}}\).</p>

<p>The relative contribution of the positional embeddings can be minimized by only leveraging the dimensions corresponding to small rotation angles:</p>

<p>\(W_Q = W_K = (\mbox{diag}(0, \dots, 0, 1, 1) \mid \mathbf{0})\), in which \(\mbox{diag}\) is a diagonal matrix. In this case \(q_{m}^T k_n = \cos((n-m) \theta_{d/2}) (x_{d-1}^2 + x_d^2)\), which for a typical choice of \(\theta_i = 10^{-4 \frac{2(i-1)}{d-2}}\) is equal to \(\cos\left(\frac{n-m}{10^4}\right)(x_{d-1}^2 + x_d^2)\). While this minimizes the effect of the rotations, it can be seen that there is still a small recency bias.</p>

<p><strong>RoPE bottleneck.</strong> Thus, it seems like RoPE creates an even tighter bottleneck than the small dimensionality of the attention heads themselves \(d_{\text{semantic}} &lt;&lt; d &lt;&lt; D\), in which \(d_{\text{semantic}}\) denotes the number of dimensions that lend themselves the most for implementing semantic attention heads.</p>

<p><strong>Experiment 3 (searching semantic heads).</strong> It should be possible to search for semantic heads by searching for \(W_Q x_m, W_K x_n\) that are bottom heavy or alternatively by looking for bottom heavy \(W_Q\) and \(W_K\).</p>

<p><strong>Experiment 4 (turning off RoPE).</strong> Given that RoPE seems to create these complications for creating purely semantic heads, it might make sense to insert layers without RoPE or let attention heads learn whether or not to use RoPE.</p>

<p><strong>Question 1 (Does the RoPE bottleneck have downstream effects?)</strong> If for semantic matching only a few dimensions are useful, how does that interact with the rest of the network? Considering a single semantic attention head, I wonder to which degree it is re-used. Are there semantic induction heads that are used for many different things? E.g., for matching countries and matching names and so on?</p>

<h1 id="dealing-with-the-attention-head-bottleneck">Dealing with the attention head bottleneck</h1>

<p>So far we only revised how to compute attention patterns. However, we also need to move information though the head. This is done by first downprojecting with \(W_V \in \mathbb{R}^{d \times D}\) and then upprojecting using \(W_O \in \mathbb{R}^{D \times d}\). All information that want’s to flow through a head, has to go through \(W_O W_V\) or in other words \(x_{\text{out}} = W_O W_V x\). This raises several questions.</p>

<p><strong>Question 2 (Are there “single” heads that can approximately transport all tokens or is the vocabulary split across multiple heads?)</strong> E.g., real previous token heads usually look exactly like the one we implemented by hand above (with \(\alpha = 100\)). This suggests that the head does not discriminate between different token identities. Similarly, transformers usually are capable to implement the famous induction pattern “A B … A -&gt; B” for all combinations of A and B (however, I think people rarely check whether individual induction heads “work” for all tokens). This raises the question how exactly transformers represent even basic things like token identities between 32000 (in Llama2) and &gt;100.000 (in more recent models) tokens with in \(d\) (= 128 in Llama2 (?)) dimensions. A naive baseline would be to, e.g., project onto the top-\(d\) principal components of $W_E$. However, this approach would be lossy. Does superposition come to the rescue (again) or do model’s always dedciate several \(W_O W_V\)’s for copying? Note that the notation here is confusing because I omitted head-indices.</p>

</body>
</html>
