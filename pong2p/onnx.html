<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Pong 2-Player (ONNX Client-Side)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- ort.all.min.js = WebGPU + WASM. Try GPU first for speed, fallback to WASM -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/ort.all.min.js"></script>
    <style>
      html, body { margin:0; min-height:100%; background:#111; color:#eee; font-family: system-ui, sans-serif; }
      #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); z-index: 9999; }
      #overlay.hidden { display: none; }
      .spinner { width: 48px; height: 48px; border: 4px solid #444; border-top-color: #09f; border-radius: 50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
      #statusText { margin-top: 12px; color: #aaa; text-align: center; font-size: 14px; }
      #app { padding: 16px; }
      button { padding: 8px 12px; background:#09f; color:#fff; border:none; border-radius:8px; cursor:pointer; }
      button:disabled { opacity: .5; cursor: not-allowed; }
      #canvasContainer { margin: 12px 0; background:#222; display: inline-block; }
      canvas#frame { image-rendering: pixelated; display: block; }
      .controls-box { margin-top: 16px; padding: 12px; background: #222; border-radius: 8px; max-width: 420px; }
      .controls-box h3 { margin: 0 0 8px 0; font-size: 14px; }
      .controls-box p { margin: 4px 0; font-size: 13px; color: #aaa; }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div>
        <div class="spinner"></div>
        <div id="statusText">Loading ONNX model…</div>
      </div>
    </div>

    <div id="app">
      <h1>Pong 2-Player <span style="color:#f80; font-size:14px;">(ONNX / WebGPU)</span></h1>
      <p style="color:#888;">Neural diffusion model runs in your browser. Fully standalone.</p>
      <div style="margin-bottom: 12px;">
        <label>Steps: <input type="number" id="stepsInput" value="4" min="1" max="10" style="width:50px;" /></label>
        <label style="margin-left:12px;">CFG: <input type="number" id="cfgInput" value="1.0" min="0" max="5" step="0.1" style="width:50px;" /></label>
      </div>
      <div>
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
      <div id="canvasContainer">
        <canvas id="frame" width="240" height="240"></canvas>
      </div>
      <div style="margin-top:12px; font-family:monospace;">
        Left: <span id="leftValue">-</span> &nbsp; Right: <span id="rightValue">-</span>
        &nbsp;|&nbsp; FPS: <span id="fpsValue">-</span>
      </div>
      <div class="controls-box">
        <h3>Controls</h3>
        <p><b>Left (W/S):</b> up/down &nbsp; <b>Right (↑/↓):</b> up/down</p>
        <p style="color:#f80;">Neural diffusion model runs in browser via ONNX Runtime Web + WebGPU.</p>
        <p style="margin-top:8px;"><a href="client.html" style="color:#0f8;">Classic Pong</a> &nbsp; <a href="debug.html" style="color:#f80;">Debug (if errors)</a></p>
      </div>
    </div>

    <script>
      if (typeof ort !== 'undefined' && ort.env) {
        if (ort.env.wasm) {
          ort.env.wasm.numThreads = 1;
          ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/';
        }
      }
      const W = 24; const H = 24; const C = 3;

      let session = null;
      let running = false;
      let leftAction = 1, rightAction = 1;
      let frameTimes = [];
      let offscreen = null;
      const actionLabels = ['INIT', 'NOOP', 'UP', 'DOWN'];

      function randn(n) {
        const out = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          let u = 0, v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          out[i] = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        }
        return out;
      }

      function linspace(start, end, n) {
        const out = [];
        for (let i = 0; i < n; i++) out.push(start + (end - start) * i / (n - 1));
        return out;
      }

      async function sample(z, leftA, rightA, nSteps, cfg) {
        const ts = linspace(1, 0, nSteps + 1).map(t => 3 * t / (2 * t + 1));
        let zArr = new Float32Array(z);
        const batch = 2;
        const actionsBatch = new BigInt64Array(batch * 1 * 2);
        actionsBatch[0] = BigInt(leftA); actionsBatch[1] = BigInt(rightA);
        actionsBatch[2] = 0n; actionsBatch[3] = 0n;

        for (let i = 0; i < ts.length - 1; i++) {
          const tVal = ts[i];
          const tArr = new Float32Array(batch);
          tArr[0] = tVal; tArr[1] = tVal;

          const zBatch = new Float32Array(batch * 1 * C * H * W);
          zBatch.set(zArr, 0);
          zBatch.set(zArr, 1 * C * H * W);

          const feeds = {
            z: new ort.Tensor('float32', zBatch, [batch, 1, C, H, W]),
            actions: new ort.Tensor('int64', actionsBatch, [batch, 1, 2]),
            t: new ort.Tensor('float32', tArr, [batch, 1])
          };

          const results = await session.run(feeds);
          let out = results.v_pred;
          if (!out && results[0]) out = results[0];
          if (!out && results instanceof Map) out = results.get('v_pred') || results.values().next().value;
          let data = out?.data;
          if (!data && typeof out?.getData === 'function') data = await out.getData();
          if (!data) throw new Error('No output data from model');
          const dt = ts[i] - ts[i + 1];

          const vCond = data.slice(0, C * H * W);
          const vNeg = data.slice(C * H * W, 2 * C * H * W);
          for (let j = 0; j < C * H * W; j++) {
            zArr[j] += dt * (vNeg[j] + cfg * (vCond[j] - vNeg[j]));
          }
        }
        return zArr;
      }

      function fixed2frame(zArr) {
        const out = new Uint8ClampedArray(W * H * 4);
        for (let i = 0; i < W * H * C; i += 3) {
          const clamp = v => Math.max(-1, Math.min(1, v));
          const r = Math.max(0, Math.min(255, Math.round((clamp(zArr[i]) * 0.5 + 0.5) * 255)));
          const g = Math.max(0, Math.min(255, Math.round((clamp(zArr[i + 1]) * 0.5 + 0.5) * 255)));
          const b = Math.max(0, Math.min(255, Math.round((clamp(zArr[i + 2]) * 0.5 + 0.5) * 255)));
          const idx = (i / 3) * 4;
          out[idx] = r; out[idx + 1] = g; out[idx + 2] = b; out[idx + 3] = 255;
        }
        return out;
      }

      async function runLoop() {
        const canvas = document.getElementById('frame');
        const ctx = canvas.getContext('2d');
        if (!offscreen) { offscreen = document.createElement('canvas'); offscreen.width = W; offscreen.height = H; }
        const offCtx = offscreen.getContext('2d');
        const steps = Math.min(10, Math.max(1, parseInt(document.getElementById('stepsInput').value) || 4));
        const cfg = parseFloat(document.getElementById('cfgInput').value) || 1.0;

        ctx.imageSmoothingEnabled = false;
        let z = randn(1 * C * H * W);

        while (running && session) {
          const t0 = performance.now();
          z = await sample(z, leftAction, rightAction, steps, cfg);
          const frame = fixed2frame(z);
          const imgData = offCtx.createImageData(W, H);
          imgData.data.set(frame);
          offCtx.putImageData(imgData, 0, 0);
          ctx.drawImage(offscreen, 0, 0, W, H, 0, 0, canvas.width, canvas.height);

          const t1 = performance.now();
          frameTimes.push(t1 - t0);
          if (frameTimes.length > 30) frameTimes.shift();
          const avg = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
          document.getElementById('fpsValue').textContent = (1000 / avg).toFixed(1);
          document.getElementById('leftValue').textContent = actionLabels[leftAction] || leftAction;
          document.getElementById('rightValue').textContent = actionLabels[rightAction] || rightAction;
        }
      }

      (async () => {
        const loadSession = (providers) => ort.InferenceSession.create('./pong2p.onnx?v=2', {
          executionProviders: providers,
          graphOptimizationLevel: 'disabled',
          enableCpuMemArena: false
        });
        const warmup = async (s) => {
          const z0 = randn(2 * C * H * W);
          const a0 = new BigInt64Array([1n, 1n, 0n, 0n]);
          const t0 = new Float32Array([0.5, 0.5]);
          const res = await s.run({
            z: new ort.Tensor('float32', z0, [2, 1, C, H, W]),
            actions: new ort.Tensor('int64', a0, [2, 1, 2]),
            t: new ort.Tensor('float32', t0, [2, 1])
          });
          const out = res.v_pred || res[0];
          if (out?.getData) await out.getData();
        };
        try {
          document.getElementById('statusText').textContent = 'Loading model (~85MB)...';
          // WebGPU first (Chrome/Edge), then WASM. Skip WebGL (error 18036544).
          const providerOrder = [['webgpu', 'wasm'], ['wasm']];
          let lastErr = null;
          for (const providers of providerOrder) {
            try {
              document.getElementById('statusText').textContent = `Loading (${providers[0]})...`;
              session = await loadSession(providers);
              document.getElementById('statusText').textContent = 'Warming up...';
              await warmup(session);
              break;
            } catch (e) {
              lastErr = e;
              if (session && session.release) try { session.release(); } catch (_) {}
              session = null;
            }
          }
          if (!session) throw lastErr || new Error('All backends failed');
          document.getElementById('overlay').classList.add('hidden');
          document.getElementById('startBtn').disabled = false;
          document.getElementById('stopBtn').disabled = false;
        } catch (err) {
          const msg = (err && (err.message || err.toString())) || 'Unknown error';
          document.getElementById('statusText').textContent = 'Error: ' + msg;
          console.error('[pong2p]', err);
          if (err?.message) document.getElementById('statusText').title = err.message;
        }
      })();

      document.getElementById('startBtn').addEventListener('click', () => {
        running = true;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        runLoop();
      });
      document.getElementById('stopBtn').addEventListener('click', () => {
        running = false;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'w' || e.key === 'W') leftAction = 2;
        else if (e.key === 's' || e.key === 'S') leftAction = 3;
        else if (e.key === 'ArrowUp') rightAction = 2;
        else if (e.key === 'ArrowDown') rightAction = 3;
        if (['w','W','s','S','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') leftAction = 1;
        else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') rightAction = 1;
      });
    </script>
  </body>
</html>
