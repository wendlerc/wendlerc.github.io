<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Pong 2-Player (ONNX Client-Side)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- ort.all.min.js = WebGPU + WASM. Try GPU first for speed, fallback to WASM -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/ort.all.min.js"></script>
    <style>
      html, body { margin:0; min-height:100%; background:#111; color:#eee; font-family: system-ui, sans-serif; }
      #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); z-index: 9999; }
      #overlay.hidden { display: none; }
      .spinner { width: 48px; height: 48px; border: 4px solid #444; border-top-color: #09f; border-radius: 50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
      #statusText { margin-top: 12px; color: #aaa; text-align: center; font-size: 14px; }
      #app { padding: 16px; }
      button { padding: 12px 20px; min-height: 44px; background:#09f; color:#fff; border:none; border-radius:8px; cursor:pointer; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
      button:disabled { opacity: .5; cursor: not-allowed; }
      #canvasContainer { margin: 12px 0; background:#222; display: inline-block; }
      canvas#frame { image-rendering: pixelated; display: block; }
      .controls-box { margin-top: 16px; padding: 12px; background: #222; border-radius: 8px; max-width: 420px; }
      .controls-box h3 { margin: 0 0 8px 0; font-size: 14px; }
      .controls-box p { margin: 4px 0; font-size: 13px; color: #aaa; }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div>
        <div class="spinner"></div>
        <div id="statusText">Loading ONNX model…</div>
      </div>
    </div>

    <div id="app" tabindex="0" style="outline:none;">
      <h1>Pong 2-Player <span style="color:#f80; font-size:14px;">(ONNX / WebGPU)</span></h1>
      <p style="color:#888;">1-step DMD distilled model runs in your browser. Fully standalone.</p>
      <div style="margin-bottom: 12px;">
        <label>Steps: <input type="number" id="stepsInput" value="1" min="1" max="10" style="width:50px;" title="1-step DMD model" /></label>
        <label style="margin-left:12px;">CFG: <input type="number" id="cfgInput" value="1.0" min="0" max="5" step="0.1" style="width:50px;" /></label>
      </div>
      <div>
        <button id="startBtn" disabled>Start</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
      <div id="canvasContainer" tabindex="0" style="outline:none; cursor:pointer;" title="Click to enable keyboard">
        <canvas id="frame" width="240" height="240"></canvas>
      </div>
      <div style="margin-top:12px; font-family:monospace;">
        Left: <span id="leftValue">-</span> &nbsp; Right: <span id="rightValue">-</span>
        &nbsp;|&nbsp; FPS: <span id="fpsValue">-</span>
      </div>
      <div class="controls-box">
        <h3>Controls</h3>
        <p><b>Left (W/S):</b> up/down &nbsp; <b>Right (↑/↓):</b> up/down</p>
        <p style="color:#888; font-size:12px;">Click canvas to enable keyboard (needed on Mac/Firefox).</p>
        <p style="color:#f80;">Neural diffusion model runs in browser via ONNX Runtime Web + WebGPU.</p>
        <p style="color:#888; font-size:12px;">First frame may take 5–10s on mobile or Mac/Safari. Click Start and wait.</p>
        <p style="color:#888; font-size:12px;">Low FPS? Try Chrome or set Steps to 2.</p>
        <p style="margin-top:8px;"><a href="client.html" style="color:#0f8;">Classic Pong</a> &nbsp; <a href="debug.html" style="color:#f80;">Debug</a> &nbsp; <a href="?webgpu=1">?webgpu=1</a> (faster, may freeze)</p>
      </div>
    </div>

    <script>
      if (typeof ort !== 'undefined' && ort.env) {
        if (ort.env.wasm) {
          ort.env.wasm.numThreads = 1;
          ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.0/dist/';
        }
      }
      const W = 24; const H = 24; const C = 3;
      // KV-cache constants (DMD 1-step: d_model=320, n_heads=20, d_head=16)
      const N_LAYERS = 8, N_HEADS = 20, D_HEAD = 16, TOKS_PER_FRAME = 65, N_WINDOW = 30;
      const CACHE_SIZE = TOKS_PER_FRAME * (N_WINDOW - 1);

      let session = null;
      let running = false;
      let leftAction = 0, rightAction = 0;
      let frameTimes = [];
      let offscreen = null;
      const actionLabels = ['INIT', 'NOOP', 'UP', 'DOWN'];
      let useCache = false;

      function createKVCache() {
        const batch = 2;
        return {
          keys: new Float32Array(N_LAYERS * batch * CACHE_SIZE * N_HEADS * D_HEAD),
          values: new Float32Array(N_LAYERS * batch * CACHE_SIZE * N_HEADS * D_HEAD),
          localLoc: 0
        };
      }
      function cacheGet(cache) {
        if (cache.localLoc === 0) return null;
        const batch = 2;
        const len = cache.localLoc * N_HEADS * D_HEAD;
        const k = new Float32Array(N_LAYERS * batch * cache.localLoc * N_HEADS * D_HEAD);
        const v = new Float32Array(N_LAYERS * batch * cache.localLoc * N_HEADS * D_HEAD);
        for (let L = 0; L < N_LAYERS; L++) {
          for (let B = 0; B < batch; B++) {
            const srcBase = ((L * 2 + B) * CACHE_SIZE) * N_HEADS * D_HEAD;
            const dstBase = ((L * 2 + B) * cache.localLoc) * N_HEADS * D_HEAD;
            for (let i = 0; i < cache.localLoc * N_HEADS * D_HEAD; i++) {
              k[dstBase + i] = cache.keys[srcBase + i];
              v[dstBase + i] = cache.values[srcBase + i];
            }
          }
        }
        return { k, v, seqLen: cache.localLoc };
      }
      function cacheExtend(cache, kNew, vNew) {
        const batch = 2;
        const T = TOKS_PER_FRAME;
        if (cache.localLoc + T > CACHE_SIZE) {
          const shift = TOKS_PER_FRAME;
          const newLoc = cache.localLoc - shift;
          for (let L = 0; L < N_LAYERS; L++) {
            for (let B = 0; B < batch; B++) {
              const base = (L * 2 + B) * CACHE_SIZE * N_HEADS * D_HEAD;
              for (let i = 0; i < newLoc * N_HEADS * D_HEAD; i++) {
                cache.keys[base + i] = cache.keys[base + (shift * N_HEADS * D_HEAD) + i];
                cache.values[base + i] = cache.values[base + (shift * N_HEADS * D_HEAD) + i];
              }
            }
          }
          cache.localLoc = newLoc;
        }
        const elemSize = T * N_HEADS * D_HEAD;
        for (let L = 0; L < N_LAYERS; L++) {
          for (let B = 0; B < batch; B++) {
            const dstBase = ((L * 2 + B) * CACHE_SIZE + cache.localLoc) * N_HEADS * D_HEAD;
            const srcBase = ((L * 2 + B) * T) * N_HEADS * D_HEAD;
            for (let i = 0; i < elemSize; i++) {
              cache.keys[dstBase + i] = kNew[srcBase + i];
              cache.values[dstBase + i] = vNew[srcBase + i];
            }
          }
        }
        cache.localLoc += T;
      }

      function randn(n) {
        const out = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          let u = 0, v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          out[i] = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        }
        return out;
      }

      function linspace(start, end, n) {
        const out = [];
        for (let i = 0; i < n; i++) out.push(start + (end - start) * i / (n - 1));
        return out;
      }

      async function sample(z, leftA, rightA, nSteps, cfg, cache) {
        const ts = linspace(1, 0, nSteps + 1).map(t => 3 * t / (2 * t + 1));
        let zArr = new Float32Array(z);
        const batch = 2;
        const actionsBatch = new BigInt64Array(batch * 1 * 2);
        actionsBatch[0] = BigInt(leftA); actionsBatch[1] = BigInt(rightA);
        actionsBatch[2] = 0n; actionsBatch[3] = 0n;

        let lastKNew = null, lastVNew = null;
        for (let i = 0; i < ts.length - 1; i++) {
          if (i > 0) await new Promise(r => setTimeout(r, 0));
          const tVal = ts[i];
          const tArr = new Float32Array(batch);
          tArr[0] = tVal; tArr[1] = tVal;

          const zBatch = new Float32Array(batch * 1 * C * H * W);
          zBatch.set(zArr, 0);
          zBatch.set(zArr, 1 * C * H * W);

          const zT = new ort.Tensor('float32', zBatch, [batch, 1, C, H, W]);
          const aT = new ort.Tensor('int64', actionsBatch, [batch, 1, 2]);
          const tT = new ort.Tensor('float32', tArr, [batch, 1]);

          const feed = { z: zT, actions: aT, t: tT };
          if (useCache && cache) {
            const cv = cacheGet(cache);
            if (cv) {
              feed.cached_k = new ort.Tensor('float32', cv.k, [N_LAYERS, batch, cv.seqLen, N_HEADS, D_HEAD]);
              feed.cached_v = new ort.Tensor('float32', cv.v, [N_LAYERS, batch, cv.seqLen, N_HEADS, D_HEAD]);
            } else {
              feed.cached_k = new ort.Tensor('float32', new Float32Array(0), [N_LAYERS, batch, 0, N_HEADS, D_HEAD]);
              feed.cached_v = new ort.Tensor('float32', new Float32Array(0), [N_LAYERS, batch, 0, N_HEADS, D_HEAD]);
            }
          }
          const results = await session.run(feed);
          if (zT.dispose) zT.dispose();
          if (aT.dispose) aT.dispose();
          if (tT.dispose) tT.dispose();
          if (feed.cached_k?.dispose) feed.cached_k.dispose();
          if (feed.cached_v?.dispose) feed.cached_v.dispose();
          let out = results.v_pred;
          if (!out && results[0]) out = results[0];
          if (!out && results instanceof Map) out = results.get('v_pred') || results.values().next().value;
          let data = out?.data;
          if (!data && typeof out?.getData === 'function') data = await out.getData();
          if (!data) throw new Error('No output data from model');
          const dt = ts[i] - ts[i + 1];

          const vCond = data.slice(0, C * H * W);
          const vNeg = data.slice(C * H * W, 2 * C * H * W);
          for (let j = 0; j < C * H * W; j++) {
            zArr[j] += dt * (vNeg[j] + cfg * (vCond[j] - vNeg[j]));
          }
          if (useCache && results.k_new) {
            lastKNew = results.k_new.data instanceof Float32Array ? results.k_new.data : new Float32Array(await results.k_new.getData());
            lastVNew = results.v_new.data instanceof Float32Array ? results.v_new.data : new Float32Array(await results.v_new.getData());
          }
          if (out && typeof out.dispose === 'function') out.dispose();
        }
        if (useCache && cache && lastKNew && lastVNew) {
          cacheExtend(cache, lastKNew, lastVNew);
        }
        return zArr;
      }

      const params = new URLSearchParams(location.search);
      const useHWC = params.get('layout') === 'hwc';
      const layout = params.get('layout') || 'transpose';
      function fixed2frame(zArr) {
        const out = new Uint8ClampedArray(W * H * 4);
        const clamp = v => Math.max(-1, Math.min(1, v));
        const toByte = v => Math.max(0, Math.min(255, Math.round((clamp(v) * 0.5 + 0.5) * 255)));
        const stride = W * H;
        if (useHWC) {
          for (let i = 0; i < W * H * C; i += 3) {
            const r = toByte(zArr[i]), g = toByte(zArr[i + 1]), b = toByte(zArr[i + 2]);
            const idx = (i / 3) * 4;
            out[idx] = r; out[idx + 1] = g; out[idx + 2] = b; out[idx + 3] = 255;
          }
        } else {
          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              let p;
              if (layout === 'transpose') {
                p = y * W + (W - 1 - x);
              } else if (layout === 'transpose_old') {
                p = x * H + y;
              } else {
                p = y * W + x;
              }
              const r = toByte(zArr[0 * stride + p]);
              const g = toByte(zArr[1 * stride + p]);
              const b = toByte(zArr[2 * stride + p]);
              const idx = (y * W + x) * 4;
              out[idx] = r; out[idx + 1] = g; out[idx + 2] = b; out[idx + 3] = 255;
            }
          }
        }
        return out;
      }

      function runLoop() {
        const canvas = document.getElementById('frame');
        const ctx = canvas.getContext('2d');
        const cw = canvas.width, ch = canvas.height;
        const steps = Math.min(10, Math.max(1, parseInt(document.getElementById('stepsInput').value) || 4));
        const cfg = parseFloat(document.getElementById('cfgInput').value) || 1.0;

        ctx.imageSmoothingEnabled = false;
        let z = randn(1 * C * H * W);
        let frameCount = 0;
        const cache = useCache ? createKVCache() : null;

        function doOneFrame() {
          if (!running || !session) return;
          if (frameCount === 0) {
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, cw, ch);
            ctx.fillStyle = '#888'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText('Computing first frame…', cw/2, ch/2);
          }
          frameCount++;
          const t0 = performance.now();
          sample(z, leftAction, rightAction, steps, cfg, cache).then(newZ => {
            z = newZ;
            for (let i = 0; i < z.length; i++) z[i] = Math.max(-1, Math.min(1, z[i]));
            const frame = fixed2frame(z);
            const imgData = ctx.createImageData(cw, ch);
            const scale = Math.floor(cw / W);
            for (let dy = 0; dy < ch; dy++) {
              for (let dx = 0; dx < cw; dx++) {
                const sy = Math.min(Math.floor(dy / scale), H - 1);
                const sx = Math.min(Math.floor(dx / scale), W - 1);
                const srcIdx = (sy * W + sx) * 4;
                const dstIdx = (dy * cw + dx) * 4;
                imgData.data[dstIdx] = frame[srcIdx];
                imgData.data[dstIdx + 1] = frame[srcIdx + 1];
                imgData.data[dstIdx + 2] = frame[srcIdx + 2];
                imgData.data[dstIdx + 3] = 255;
              }
            }
            ctx.putImageData(imgData, 0, 0);
            const t1 = performance.now();
            frameTimes.push(t1 - t0);
            if (frameTimes.length > 30) frameTimes.shift();
            const avg = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
            document.getElementById('fpsValue').textContent = (1000 / avg).toFixed(1);
            document.getElementById('leftValue').textContent = actionLabels[leftAction] || leftAction;
            document.getElementById('rightValue').textContent = actionLabels[rightAction] || rightAction;
            setTimeout(doOneFrame, 100);
          }).catch(e => {
            console.error('[pong2p] sample error', e);
            document.getElementById('fpsValue').textContent = 'err';
            document.getElementById('statusText').textContent = 'Error: ' + (e?.message || e);
          });
        }
        doOneFrame();
      }

      (async () => {
        const loadSession = (providers) => ort.InferenceSession.create('./pong2p_dmd.onnx?v=1', {
          executionProviders: providers,
          graphOptimizationLevel: 'disabled',
          enableCpuMemArena: false
        });
        const warmup = async (s) => {
          const z0 = randn(2 * C * H * W);
          const a0 = new BigInt64Array([1n, 1n, 0n, 0n]);
          const t0 = new Float32Array([0.5, 0.5]);
          const feed = {
            z: new ort.Tensor('float32', z0, [2, 1, C, H, W]),
            actions: new ort.Tensor('int64', a0, [2, 1, 2]),
            t: new ort.Tensor('float32', t0, [2, 1])
          };
          if (s.inputNames && s.inputNames.includes('cached_k')) {
            feed.cached_k = new ort.Tensor('float32', new Float32Array(0), [N_LAYERS, 2, 0, N_HEADS, D_HEAD]);
            feed.cached_v = new ort.Tensor('float32', new Float32Array(0), [N_LAYERS, 2, 0, N_HEADS, D_HEAD]);
          }
          const res = await s.run(feed);
          const out = res.v_pred || res[0];
          if (out?.getData) await out.getData();
        };
        try {
          document.getElementById('statusText').textContent = 'Loading DMD model (~81MB)...';
          const params = new URLSearchParams(location.search);
          const useWebGPU = params.get('webgpu') === '1';
          const providerOrder = useWebGPU ? [['webgpu', 'wasm'], ['wasm']] : [['wasm']];
          let lastErr = null;
          for (const providers of providerOrder) {
            try {
              document.getElementById('statusText').textContent = `Loading (${providers[0]})...`;
              session = await loadSession(providers);
              document.getElementById('statusText').textContent = 'Warming up...';
              await warmup(session);
              break;
            } catch (e) {
              lastErr = e;
              if (session && session.release) try { session.release(); } catch (_) {}
              session = null;
            }
          }
          if (!session) throw lastErr || new Error('All backends failed');
          useCache = session.inputNames && session.inputNames.includes('cached_k');
          if (useCache) console.log('[pong2p] KV-cache enabled');
          document.getElementById('overlay').classList.add('hidden');
          document.getElementById('startBtn').disabled = false;
          document.getElementById('stopBtn').disabled = false;
        } catch (err) {
          const msg = (err && (err.message || err.toString())) || 'Unknown error';
          document.getElementById('statusText').textContent = 'Error: ' + msg;
          console.error('[pong2p]', err);
          if (err?.message) document.getElementById('statusText').title = err.message;
        }
      })();

      function onStart() {
        if (!session || running) return;
        running = true;
        document.getElementById('startBtn').disabled = true;
        document.getElementById('startBtn').textContent = 'Starting…';
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('fpsValue').textContent = '…';
        document.getElementById('canvasContainer').focus();
        runLoop().catch(e => {
          document.getElementById('startBtn').textContent = 'Start';
          document.getElementById('statusText').textContent = 'Error: ' + (e?.message || e);
          console.error('[pong2p] runLoop', e);
          running = false;
          document.getElementById('startBtn').disabled = false;
          document.getElementById('stopBtn').disabled = true;
        });
      }
      function onStop() {
        running = false;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('startBtn').textContent = 'Start';
        document.getElementById('stopBtn').disabled = true;
      }
      function handlePointer(e) { e.preventDefault(); onStart(); }
      function handleStopPointer(e) { e.preventDefault(); onStop(); }
      document.getElementById('startBtn').addEventListener('click', onStart);
      document.getElementById('startBtn').addEventListener('touchend', handlePointer, { passive: false });
      document.getElementById('startBtn').addEventListener('pointerup', handlePointer);
      document.getElementById('stopBtn').addEventListener('click', onStop);
      document.getElementById('stopBtn').addEventListener('touchend', handleStopPointer, { passive: false });
      document.getElementById('stopBtn').addEventListener('pointerup', handleStopPointer);
      document.getElementById('canvasContainer').addEventListener('click', () => document.getElementById('canvasContainer').focus());

      document.addEventListener('keydown', (e) => {
        if (e.key === 'w' || e.key === 'W') leftAction = 2;
        else if (e.key === 's' || e.key === 'S') leftAction = 3;
        else if (e.key === 'ArrowUp') rightAction = 2;
        else if (e.key === 'ArrowDown') rightAction = 3;
        if (['w','W','s','S','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') leftAction = 1;
        else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') rightAction = 1;
      });
    </script>
  </body>
</html>
